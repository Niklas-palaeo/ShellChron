kernel = "gaussian")
# Export histogram to PDF
pdf("d18O_residual_histogram.pdf", width = 5, height = 5)
plot(d18Omodhist)
dev.off()
# Import age model results
AMres <- as.data.frame(read.csv("Age_model_results.csv", header = TRUE))
rownames(AMres) <- AMres$X # Add sample names as headers
AMres$X <- NULL # Remove X column
# Plot age model result plot
AMplot <- ggplot(data = AMres, aes(D, mean.day)) +
geom_ribbon(aes(ymin = mean.day - qt(0.95, N) * sd.day / sqrt(N),
ymax = mean.day + qt(0.95, N) * sd.day / sqrt(N)),
alpha = 0.5,
col = "grey") +
geom_line(size = 1) +
geom_line(aes(x = D, y = mean.day + qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
geom_line(aes(x = D, y = mean.day - qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
scale_y_continuous("Age (days)",
breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365),
minor_breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365 / 12)) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 5000)) +
ggtitle("Results of age model (Age in days vs. Depth in micrometers)")
# Export age model plot to PDF
pdf("Age_model_plot.pdf", width = 6, height = 6)
plot(AMplot)
dev.off()
# setwd("C:/Users//niels//Dropbox/Research/Manuscripts/Bivalve age model/tests/Case1_HR_results_new")
setwd("E:/Dropbox/Research/Manuscripts/Bivalve age model/tests/Pros20_results_new")
# Import d18O model data
dOraw <- as.data.frame(read.csv("modelled_d18O_raw.csv", header = TRUE))
rownames(dOraw) <- dOraw$X # Add sample names as headers
dOraw$X <- NULL # Remove X column
d18Otidy <- gather(dOraw,
"window",
"d18O_mod",
6:ncol(dOraw),
factor_key = TRUE
) # Convert modelled d18O results to Tidy data for plotting
rho <- cor(d18Otidy$d18Oc,# Calculate Spearman's correlation coefficient
d18Otidy$d18O_mod,
use = "pairwise.complete.obs",
method = "spearman"
)
d18Odiff <- data.frame(diff = d18Otidy$d18O_mod - d18Otidy$d18Oc)
SDrep <- sd(d18Odiff$diff, na.rm = TRUE) # Calculate st error of estimate (stdev of reproducibility)
stats_table <- cbind(
statistic = c("Spearman's correlation coefficient",
"Standard error of the estimate"),
value = c(round(rho, 2), round(SDrep, 3)),
unit = c("-", "permille")
)
# Create base plot of input data
d18Omodplot <- ggplot(data = dOraw, aes(D, d18Oc))
# Loop through windows to add results per window
for(window in seq(1, ncol(dOraw) - 5, 1)){
d18Omodplot <- d18Omodplot +
geom_line(aes_string(x = "D", y = paste("window.", window, sep = "")),
col = "red",
alpha = 0.2,
size = 2)
}
# Add top layer of input data
d18Omodplot <- d18Omodplot +
geom_point(size = 1, shape = 15) +
geom_errorbar(aes(ymin = d18Oc - d18Oc_err, # Add error bars on data (1 SD)
ymax = d18Oc + d18Oc_err),
width = dOraw$D_err) +
geom_errorbarh(aes(xmin = D - D_err,
xmax = D + D_err),
height = dOraw$d18Oc_err) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 5000)) +
ggtitle("Simulations of d18O data (red) superimposed on input data (black)") +
scale_y_continuous("d18Oc value (permille VPDB",
breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.5),
minor_breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.1)) +
annotation_custom(tableGrob(stats_table),
xmin = 0,
xmax = 30,
ymin = -3,
ymax = -2)
# Export model result plot to PDF
pdf("d18O_model_result_plot.pdf", width = 10, height = 5)
plot(d18Omodplot)
dev.off()
# Histogram of d18O residuals
d18Omodhist <- ggplot(data = d18Odiff, aes(diff)) +
geom_histogram(aes(y = ..density..),
binwidth = 0.01,
center = 0.005,
na.rm = TRUE,
col = "grey") +
geom_vline(xintercept = 0,
col = "red",
size = 1) +
geom_density(aes(y = ..density..),
bw = "nrd0",
kernel = "gaussian")
# Export histogram to PDF
pdf("d18O_residual_histogram.pdf", width = 5, height = 5)
plot(d18Omodhist)
dev.off()
# Import age model results
AMres <- as.data.frame(read.csv("Age_model_results.csv", header = TRUE))
rownames(AMres) <- AMres$X # Add sample names as headers
AMres$X <- NULL # Remove X column
# Plot age model result plot
AMplot <- ggplot(data = AMres, aes(D, mean.day)) +
geom_ribbon(aes(ymin = mean.day - qt(0.95, N) * sd.day / sqrt(N),
ymax = mean.day + qt(0.95, N) * sd.day / sqrt(N)),
alpha = 0.5,
col = "grey") +
geom_line(size = 1) +
geom_line(aes(x = D, y = mean.day + qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
geom_line(aes(x = D, y = mean.day - qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
scale_y_continuous("Age (days)",
breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365),
minor_breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365 / 12)) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 5000)) +
ggtitle("Results of age model (Age in days vs. Depth in micrometers)")
# Export age model plot to PDF
pdf("Age_model_plot.pdf", width = 6, height = 6)
plot(AMplot)
dev.off()
# Import d18O model data
dOraw <- as.data.frame(read.csv("modelled_d18O_raw.csv", header = TRUE))
rownames(dOraw) <- dOraw$X # Add sample names as headers
dOraw$X <- NULL # Remove X column
d18Otidy <- gather(dOraw,
"window",
"d18O_mod",
6:ncol(dOraw),
factor_key = TRUE
) # Convert modelled d18O results to Tidy data for plotting
rho <- cor(d18Otidy$d18Oc,# Calculate Spearman's correlation coefficient
d18Otidy$d18O_mod,
use = "pairwise.complete.obs",
method = "spearman"
)
d18Odiff <- data.frame(diff = d18Otidy$d18O_mod - d18Otidy$d18Oc)
SDrep <- sd(d18Odiff$diff, na.rm = TRUE) # Calculate st error of estimate (stdev of reproducibility)
stats_table <- cbind(
statistic = c("Spearman's correlation coefficient",
"Standard error of the estimate"),
value = c(round(rho, 2), round(SDrep, 3)),
unit = c("-", "permille")
)
# Create base plot of input data
d18Omodplot <- ggplot(data = dOraw, aes(D, d18Oc))
# Loop through windows to add results per window
for(window in seq(1, ncol(dOraw) - 5, 1)){
d18Omodplot <- d18Omodplot +
geom_line(aes_string(x = "D", y = paste("window.", window, sep = "")),
col = "red",
alpha = 0.2,
size = 2)
}
# Add top layer of input data
d18Omodplot <- d18Omodplot +
geom_point(size = 1, shape = 15) +
geom_line() +
geom_errorbar(aes(ymin = d18Oc - d18Oc_err, # Add error bars on data (1 SD)
ymax = d18Oc + d18Oc_err),
width = dOraw$D_err) +
geom_errorbarh(aes(xmin = D - D_err,
xmax = D + D_err),
height = dOraw$d18Oc_err) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 5000)) +
ggtitle("Simulations of d18O data (red) superimposed on input data (black)") +
scale_y_continuous("d18Oc value (permille VPDB",
breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.5),
minor_breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.1)) +
annotation_custom(tableGrob(stats_table),
xmin = 0,
xmax = 30,
ymin = -3,
ymax = -2)
# Export model result plot to PDF
pdf("d18O_model_result_plot.pdf", width = 10, height = 5)
plot(d18Omodplot)
dev.off()
# setwd("C:/Users//niels//Dropbox/Research/Manuscripts/Bivalve age model/tests/Case1_HR_results_new")
setwd("E:/Dropbox/Research/Manuscripts/Bivalve age model/tests/Gagan_coral_new")
# Import d18O model data
dOraw <- as.data.frame(read.csv("modelled_d18O_raw.csv", header = TRUE))
rownames(dOraw) <- dOraw$X # Add sample names as headers
dOraw$X <- NULL # Remove X column
d18Otidy <- gather(dOraw,
"window",
"d18O_mod",
6:ncol(dOraw),
factor_key = TRUE
) # Convert modelled d18O results to Tidy data for plotting
rho <- cor(d18Otidy$d18Oc,# Calculate Spearman's correlation coefficient
d18Otidy$d18O_mod,
use = "pairwise.complete.obs",
method = "spearman"
)
d18Odiff <- data.frame(diff = d18Otidy$d18O_mod - d18Otidy$d18Oc)
SDrep <- sd(d18Odiff$diff, na.rm = TRUE) # Calculate st error of estimate (stdev of reproducibility)
stats_table <- cbind(
statistic = c("Spearman's correlation coefficient",
"Standard error of the estimate"),
value = c(round(rho, 2), round(SDrep, 3)),
unit = c("-", "permille")
)
# Create base plot of input data
d18Omodplot <- ggplot(data = dOraw, aes(D, d18Oc))
# Loop through windows to add results per window
for(window in seq(1, ncol(dOraw) - 5, 1)){
d18Omodplot <- d18Omodplot +
geom_line(aes_string(x = "D", y = paste("window.", window, sep = "")),
col = "red",
alpha = 0.2,
size = 2)
}
# Add top layer of input data
d18Omodplot <- d18Omodplot +
geom_point(size = 1, shape = 15) +
geom_line() +
geom_errorbar(aes(ymin = d18Oc - d18Oc_err, # Add error bars on data (1 SD)
ymax = d18Oc + d18Oc_err),
width = dOraw$D_err) +
geom_errorbarh(aes(xmin = D - D_err,
xmax = D + D_err),
height = dOraw$d18Oc_err) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 5000)) +
ggtitle("Simulations of d18O data (red) superimposed on input data (black)") +
scale_y_continuous("d18Oc value (permille VPDB",
breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.5),
minor_breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.1)) +
annotation_custom(tableGrob(stats_table),
xmin = 0,
xmax = 30,
ymin = -3,
ymax = -2)
# Export model result plot to PDF
pdf("d18O_model_result_plot.pdf", width = 10, height = 5)
plot(d18Omodplot)
dev.off()
# Histogram of d18O residuals
d18Omodhist <- ggplot(data = d18Odiff, aes(diff)) +
geom_histogram(aes(y = ..density..),
binwidth = 0.01,
center = 0.005,
na.rm = TRUE,
col = "grey") +
geom_vline(xintercept = 0,
col = "red",
size = 1) +
geom_density(aes(y = ..density..),
bw = "nrd0",
kernel = "gaussian")
# Export histogram to PDF
pdf("d18O_residual_histogram.pdf", width = 5, height = 5)
plot(d18Omodhist)
dev.off()
# Import age model results
AMres <- as.data.frame(read.csv("Age_model_results.csv", header = TRUE))
rownames(AMres) <- AMres$X # Add sample names as headers
AMres$X <- NULL # Remove X column
# Plot age model result plot
AMplot <- ggplot(data = AMres, aes(D, mean.day)) +
geom_ribbon(aes(ymin = mean.day - qt(0.95, N) * sd.day / sqrt(N),
ymax = mean.day + qt(0.95, N) * sd.day / sqrt(N)),
alpha = 0.5,
col = "grey") +
geom_line(size = 1) +
geom_line(aes(x = D, y = mean.day + qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
geom_line(aes(x = D, y = mean.day - qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
scale_y_continuous("Age (days)",
breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365),
minor_breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365 / 12)) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 5000)) +
ggtitle("Results of age model (Age in days vs. Depth in micrometers)")
# Export age model plot to PDF
pdf("Age_model_plot.pdf", width = 6, height = 6)
plot(AMplot)
dev.off()
# setwd("C:/Users//niels//Dropbox/Research/Manuscripts/Bivalve age model/tests/Case1_HR_results_new")
setwd("E:/Dropbox/Research/Manuscripts/Bivalve age model/tests/Ullmann_results_new")
# Import d18O model data
dOraw <- as.data.frame(read.csv("modelled_d18O_raw.csv", header = TRUE))
rownames(dOraw) <- dOraw$X # Add sample names as headers
dOraw$X <- NULL # Remove X column
d18Otidy <- gather(dOraw,
"window",
"d18O_mod",
6:ncol(dOraw),
factor_key = TRUE
) # Convert modelled d18O results to Tidy data for plotting
rho <- cor(d18Otidy$d18Oc,# Calculate Spearman's correlation coefficient
d18Otidy$d18O_mod,
use = "pairwise.complete.obs",
method = "spearman"
)
d18Odiff <- data.frame(diff = d18Otidy$d18O_mod - d18Otidy$d18Oc)
SDrep <- sd(d18Odiff$diff, na.rm = TRUE) # Calculate st error of estimate (stdev of reproducibility)
stats_table <- cbind(
statistic = c("Spearman's correlation coefficient",
"Standard error of the estimate"),
value = c(round(rho, 2), round(SDrep, 3)),
unit = c("-", "permille")
)
# Create base plot of input data
d18Omodplot <- ggplot(data = dOraw, aes(D, d18Oc))
# Loop through windows to add results per window
for(window in seq(1, ncol(dOraw) - 5, 1)){
d18Omodplot <- d18Omodplot +
geom_line(aes_string(x = "D", y = paste("window.", window, sep = "")),
col = "red",
alpha = 0.2,
size = 2)
}
# Add top layer of input data
d18Omodplot <- d18Omodplot +
geom_point(size = 1, shape = 15) +
geom_line() +
geom_errorbar(aes(ymin = d18Oc - d18Oc_err, # Add error bars on data (1 SD)
ymax = d18Oc + d18Oc_err),
width = dOraw$D_err) +
geom_errorbarh(aes(xmin = D - D_err,
xmax = D + D_err),
height = dOraw$d18Oc_err) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(dOraw$D) / 10000) * 10000, ceiling(max(dOraw$D) / 10000) * 10000, 5000)) +
ggtitle("Simulations of d18O data (red) superimposed on input data (black)") +
scale_y_continuous("d18Oc value (permille VPDB",
breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.5),
minor_breaks = seq(floor(min(dOraw$d18Oc)), ceiling(max(dOraw$d18Oc)), 0.1)) +
annotation_custom(tableGrob(stats_table),
xmin = 0,
xmax = 30,
ymin = -3,
ymax = -2)
# Export model result plot to PDF
pdf("d18O_model_result_plot.pdf", width = 10, height = 5)
plot(d18Omodplot)
dev.off()
# Histogram of d18O residuals
d18Omodhist <- ggplot(data = d18Odiff, aes(diff)) +
geom_histogram(aes(y = ..density..),
binwidth = 0.01,
center = 0.005,
na.rm = TRUE,
col = "grey") +
geom_vline(xintercept = 0,
col = "red",
size = 1) +
geom_density(aes(y = ..density..),
bw = "nrd0",
kernel = "gaussian")
# Export histogram to PDF
pdf("d18O_residual_histogram.pdf", width = 5, height = 5)
plot(d18Omodhist)
dev.off()
# Import age model results
AMres <- as.data.frame(read.csv("Age_model_results.csv", header = TRUE))
rownames(AMres) <- AMres$X # Add sample names as headers
AMres$X <- NULL # Remove X column
# Plot age model result plot
AMplot <- ggplot(data = AMres, aes(D, mean.day)) +
geom_ribbon(aes(ymin = mean.day - qt(0.95, N) * sd.day / sqrt(N),
ymax = mean.day + qt(0.95, N) * sd.day / sqrt(N)),
alpha = 0.5,
col = "grey") +
geom_line(size = 1) +
geom_line(aes(x = D, y = mean.day + qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
geom_line(aes(x = D, y = mean.day - qt(0.95, N) * sd.day / sqrt(N)), col = "grey", size = 0.5) +
scale_y_continuous("Age (days)",
breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365),
minor_breaks = seq(floor(min(AMres$mean.day / 365)) * 365, ceiling(max(AMres$mean.day / 365)) * 365, 365 / 12)) +
scale_x_continuous("Length along record (micrometers)",
breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 10000),
minor_breaks = seq(floor(min(AMres$D) / 10000) * 10000, ceiling(max(AMres$D) / 10000) * 10000, 5000)) +
ggtitle("Results of age model (Age in days vs. Depth in micrometers)")
# Export age model plot to PDF
pdf("Age_model_plot.pdf", width = 6, height = 6)
plot(AMplot)
dev.off()
devtools::install()
install.packages(c("broom", "labeling", "lme4", "openxlsx", "quantreg", "R6", "RcppArmadillo", "rmarkdown"))
devtools::install()
install.packages("digest")
devtools::install()
path <- "C://Users//niels//Dropbox//Research//Manuscripts//Bivalve age model//tests//Ullmann_results_new" # For laptop
setwd(path)
file_name <- "Ullmann2010.csv" # Give file name (don't forget to add the extention, should be in CSV format)
mineral <- "calcite" # Set mineralogy of the record
t_int <- 1 # Set time interval in days
G_per <- T_per <- 365 # Set annual time period in days (default = 365)
#Texel_data <- read.csv("Texel_daily_data.csv", header = T)
d18Ow <- read.csv("d18Osw.csv", header = FALSE)$V1 # Create d18Ow vector for one year (default = all zero)
# d18Ow <- -7.65
t_maxtemp <- 182.5 # Assume taht the day of maximum temperature is halfway through the year.
MC <- 1000
agecorrection <- FALSE
plot <- TRUE
plot_export <- TRUE
export_raw <- TRUE
path <- "E://Dropbox//Research//Manuscripts//Bivalve age model//tests//Ullmann_results_new" # For Home PC (both)
#path <- "C://Users//niels//Dropbox//Research//Manuscripts//Bivalve age model//tests//Ullmann_results_new" # For laptop
setwd(path)
file_name <- "Ullmann2010.csv" # Give file name (don't forget to add the extention, should be in CSV format)
mineral <- "calcite" # Set mineralogy of the record
t_int <- 1 # Set time interval in days
G_per <- T_per <- 365 # Set annual time period in days (default = 365)
#Texel_data <- read.csv("Texel_daily_data.csv", header = T)
d18Ow <- read.csv("d18Osw.csv", header = FALSE)$V1 # Create d18Ow vector for one year (default = all zero)
# d18Ow <- -7.65
t_maxtemp <- 182.5 # Assume taht the day of maximum temperature is halfway through the year.
MC <- 1000
agecorrection <- FALSE
plot <- TRUE
plot_export <- TRUE
export_raw <- TRUE
require(ShellChron)
# STEP 1: Import data
setwd(path)
importlist <- data_import(file_name)
dat <- importlist[[1]]
dynwindow <- importlist[[2]]
G_per <- T_per
# STEP 2: Run the model
resultlist <- run_model(dat, dynwindow, mineral, d18Ow, T_per, G_per, t_int, t_maxtemp, MC, agecorrection, plot = TRUE)
resultlist <- run_model(dat, dynwindow, mineral, d18Ow, T_per, G_per, t_int, t_maxtemp, MC, plot = TRUE)
# Prepare data arrays for storage of modelling results
resultarray <- array( # Create array to contain all modelling results of overlapping windows
rep(as.matrix(cbind(dat, matrix(NA, ncol = length(dynwindow$x), nrow = length(dat$D)))), 9), # Replicate matrix of dat + extra columns to contain all variables
dim = c(length(dat$D), length(dynwindow$x) + length(dat[1,]), 9) # Six variables, being: Modelled d18O, residuals, Day of the Year, Growth between datapoints, Instantaneous growth rate at datapoint and Modelled temperature
)
parmat <- matrix(NA, nrow = 7, ncol = length(dynwindow$x)) # Matrix in which to store the modelling parameters
colnames(parmat) <- dynwindow$x
rownames(parmat) <- c("T_amp", "T_pha", "T_av", "G_amp", "G_pha", "G_av", "G_skw")
# Prepare plot to show model progress
if(plot == TRUE){
dev.new()
fitplot <- ggplot2::ggplot(dat, ggplot2::aes(D, d18Oc)) + # Create a plot showing the fit of each window on the original data, start with a plot of the original data
ggplot2::geom_point() +
ggplot2::geom_line() +
ggplot2::geom_errorbar(ggplot2::aes(ymin = d18Oc - d18Oc_err, # Add error bars on model result (1 SD)
ymax = d18Oc + d18Oc_err),
width = dat$D_err) +
ggplot2::geom_errorbarh(ggplot2::aes(xmin = D - D_err,
xmax = D + D_err),
height = 0.05) +
ggplot2::ggtitle("Plot of d18Oc values vs. depth. Black = data, Red = model, Errorbars = 1 SD")
plot(fitplot)
}
# Estimate growth rate variability and round up to nearest multiple of 100 for conservative boundary
GRavmax <- ceiling(max(diff(dat[dat$YEARMARKER == 1,1])) / 365 / 100) * 100
# Find tailored range of temperatures from data
d18Oc_range <- range(dat$d18Oc) # Find d18Oc range in data
if(mineral == "calcite"){ # Find temperature range (to be superseded with inverse d18O_model function in later updates)
T_range <- 18.03 * 1000 / (log((d18Oc_range - (0.97002 * d18Ow - 29.98)) / 1000 + 1) * 1000 + 32.42) - 273.15 # Use Kim and O'Neil (1997) with conversion between VSMOW and VPDB by Brand et al. (2014)
}else if(mineral == "aragonite"){
T_range <-  20.6 - 4.34 * (d18Oc_range - d18Ow - 0.2) # Use Grossmann and Ku (1986) modified by Dettmann et al. (1999)
}else{
print("ERROR: Supplied mineralogy is not recognized")
}
T_max <- max(T_range)
T_amp_max <- 2 * abs(diff(T_range))
# Collate lower boundaries of parameters
parl <- c(
T_amp = 0, # Minimum T amplitude in degrees C
T_pha = 0, # Minimum phase in days
T_av = -4, # Minimum average T in degrees C
G_amp = 0, # Minimum seasonal GR range in um/d
G_pha = 0, # Minimum GR phase in days
G_av = -1 * GRavmax, # Minimum average GR in um/d.
G_skw = 0 # Minimum skew factor
)
# Collate upper boundaries of parameters
paru <- c(
T_amp = round(T_amp_max + 0.5, 0), # Maximum T amplitude in degrees C
T_pha = 365, # Maximum phase in days
T_av = round(T_max + 0.5, 0), # Maximum average T in degrees C
G_amp = 2 * GRavmax, # Maximum seasonal GR range in um/d
G_pha = 365, # Maximum GR phase in days
G_av = GRavmax, # Maximum average GR in um/d (based on conservative boundaries of YEARMARKER indicators)
G_skw = 100 # Maximum skew factor
)
# Set parameters for SCEUA optimization
iniflg = 1 # Flag for initial parameter array (1 = included)
ngs = 25 # Number of complexes (sub-populations)
maxn = 10000 # Maximum number of function evaluations allowed during optimization
kstop = 5 # Maximum number of evolution loops before convergency
pcento = 0.01 # Percentage change allowed in function value criterion before stop
peps = 0.01 # Convergence level for parameter set (difference between parameters required for stop)
range(1)
T_range <- 18.03 * 1000 / (log((d18Oc_range - (0.97002 * range(d18Ow) - 29.98)) / 1000 + 1) * 1000 + 32.42) - 273.15
range(c(1,2,3))
t(range(c(1,2,3)))
range(c(1,2,3))
rev(range(c(1,2,3)))
T_range2 <- 18.03 * 1000 / (log((d18Oc_range - (0.97002 * rev(range(d18Ow)) - 29.98)) / 1000 + 1) * 1000 + 32.42) - 273.15
T_range <-  20.6 - 4.34 * (d18Oc_range - rev(range(d18Ow)) - 0.2)
T_range2 <-  20.6 - 4.34 * (d18Oc_range - range(d18Ow) - 0.2) # Use Grossmann and Ku (1986) modified by Dettmann et al. (1999)
devtools::document()
