diff(range(Dsam)) / O_per_start
rm(list=ls9)
rm(list=ls())
devtools::document()
devtools::install()
wrap_function(path = "E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case",
file_name = "Short_case.csv",
"KimONeil97",
1,
365,
0,
182.5,
c(1, 25, 10000, 5, 0.01, 0.01),
sinfit = TRUE,
1000,
plot = TRUE,
plot_export = TRUE,
export_raw = TRUE,
export_path = "E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case/test results_std"
)
wrap_function(path = "E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case",
file_name = "Short_case.csv",
"KimONeil97",
1,
365,
0,
182.5,
c(1, 25, 10000, 5, 0.01, 0.01),
sinfit = TRUE,
1000,
plot = TRUE,
plot_export = TRUE,
export_raw = TRUE,
export_path = "E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case/test results_std"
)
require(ShellChron)
# Import data using "data_import"
importlist <- data_import("E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case/Short_case.csv")
if(length(importlist) != 2){ # Catch errors in the input data
return("ERROR: Input data does not match the default input data format")
}
dat <- importlist[[1]]
dynwindow <- importlist[[2]]
G_per <- Tper <- 365
# Run model under "normal" conditions
resultlist <- run_model(dat, dynwindow, "KimONeil97", 0, 365, 365, 1, 182.5, c(1, 25, 10000, 5, 0.01, 0.01), TRUE, 1000, plot = TRUE)
resultarray <- resultlist[[1]]
parmat <- resultlist[[2]]
setwd(""E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case/")
setwd("E:/Dropbox/Research/Manuscripts/[Review] GMD - Bivalve age model/tests/Short case/")
plotyearmarkers = TRUE; # Plot peak fitting?
export_peakid = TRUE
resultarray_original <- resultarray
dat <- resultarray[, 1:5, 3]
View(dat)
JDdat <- round(resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3])
View(JDdat)
JDdat <- matrix(sin(2 * pi * (JDdat + 365/4) / 365), ncol = ncol(JDdat)) # Convert julian day to sinusoidal value (end and start of year = 1)
JDends <- data.frame(Depth = dat[, 1],
Yearmarker = dat[, 3],
YEsin = scales::rescale(rowSums(JDdat, na.rm = TRUE), c(0, 1)) # Create depth series of positions which most likely represent a year end, rescale to a scale from 0 to 1
)
View(JDends)
weightvector <- c(seq(10, 1, -1), rep(0, 346), seq(1, 10, 1)) # Create vector of weights to be given to days near the start and end of the year
JDdat <- round(resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3]) # Isolate julian day simulations
View(JDdat)
JDdat <- matrix(weightvector[JDdat + 1], ncol = ncol(JDdat)) # Apply weighting to starts and ends of the year
JDends$YEweight <- scales::rescale(rowSums(JDdat, na.rm = TRUE), c(0, 1)) # Add normalized results to depth series
View(JDdat)
View(JDends)
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
View(JDdat)
JDdat <- matrix(sin(2 * pi * (JDdat + 365/4) / 365), ncol = ncol(JDdat)) # Convert julian day to sinusoidal value (end and start of year = 1)
JDends <- data.frame(Depth = dat[, 1],
Yearmarker = dat[, 3],
YEsin = scales::rescale(rowSums(JDdat, na.rm = TRUE), c(0, 1)) # Create depth series of positions which most likely represent a year end, rescale to a scale from 0 to 1
)
View(JDends)
dat <- resultarray[, 1:5, 3] # isolate original data
# Recognition of the boundaries between years.
# Method one: Apply sinusoidal function to the julian day simulations
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
JDdat <- matrix(sin(2 * pi * (JDdat + 365/4) / 365), ncol = ncol(JDdat)) # Convert julian day to sinusoidal value (end and start of year = 1)
JDends <- data.frame(Depth = dat[, 1],
Yearmarker = dat[, 3],
YEsin = scales::rescale(rowSums(JDdat, na.rm = TRUE), c(0, 1)) # Create depth series of positions which most likely represent a year end, rescale to a scale from 0 to 1
)
View(JDdat)
View(JDends)
weightvector <- c(seq(10, 1, -1), rep(0, 346), seq(1, 10, 1)) # Create vector of weights to be given to days near the start and end of the year
JDdat <- round(resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3]) # Isolate julian day simulations
JDdat <- matrix(weightvector[JDdat + 1], ncol = ncol(JDdat)) # Apply weighting to starts and ends of the year
JDends$YEweight <- scales::rescale(rowSums(JDdat, na.rm = TRUE), c(0, 1)) # Add normalized results to depth series
# Method three: Use instances within the window simulations where the end of year is recorded
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
JDdat <- rbind(rep(NA, length(JDdat[1, ])), diff(JDdat) < 0) # Matrix of positions in individual windows where end of year (day 365) is recorded
View(JDdat)
YEcount <- rowSums(JDdat, na.rm = TRUE) / max(rowSums(JDdat, na.rm = TRUE), na.rm = TRUE) # Aggregate the counted ends of years in simulations
YEcount
View(JDends)
smoothfactor <- min(diff(which(JDends[, 2] == 1))) # Define smoothing factor for year end counts based on yearmarkers (take thickness of year with least growth to be conservative)
smoothfactor
YEcount <- c(rep(0, floor(smoothfactor / 2)), zoo::rollmean(YEcount, smoothfactor, align = "center"), rep(0, smoothfactor - floor(smoothfactor / 2) - 1)) # Smooth record of year end counts and pad with zeroes
YEcount
JDends$YEcount <- scales::rescale(YEcount, c(0, 1)) # Add normalized results to depth series
yearpos <- c(1, which(JDends[, 2] == 1), length(JDends$Depth)) # Extract positions of yearmarkers and include start and end of record
yearpos
yearpos <- unique(yearpos) # Remove duplicates in yearpos due to yearmarkers on beginning and/or end of record
yearpos
YE18O <- vector() # Create vector for the position of the maximum d18O value
m = 3
maxpos <- which(dat[yearpos[m] : (yearpos[m + 1] - 1), 2] == max(dat[yearpos[m] : (yearpos[m + 1] - 1), 2])) + yearpos[m] - 1
maxpos
View(dat)
yearpos <- c(1, which(JDends[, 2] == 1), length(JDends$Depth)) # Extract positions of yearmarkers and include start and end of record
yearpos <- unique(yearpos) # Remove duplicates in yearpos due to yearmarkers on beginning and/or end of record
YE18O <- vector() # Create vector for the position of the maximum d18O value
for(m in 1:(length(yearpos) - 1)){ # Loop through positions of yearmarkers
if(m %in% 2:(length(yearpos) - 2)){ # central part of the record
maxpos <- which(dat[yearpos[m] : (yearpos[m + 1] - 1), 2] == max(dat[yearpos[m] : (yearpos[m + 1] - 1), 2])) + yearpos[m] - 1 # Find the position of the maximum value in the d18O data in that year
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(1, yearpos[m + 1] - yearpos[m], 1) * 365 / (yearpos[m + 1] - yearpos[m]) # Define sequence of "days" values with length = number of datapoints in the year
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) + 0.5) * 365 | days < ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid) # add sinusoid values to running vector
}else if(m == 1){ # beginning of the record
maxpos <- which(dat[yearpos[m + 1] : (yearpos[m + 2] - 1), 2] == max(dat[yearpos[m + 1] : (yearpos[m + 2] - 1), 2])) + yearpos[m + 1] - 1 # Find the position of the maximum value in the d18O data of the next year (the first year that is complete)
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(yearpos[m] - yearpos[m + 1] + 1, yearpos[m + 2] - yearpos[m + 1], 1) * 365 / (yearpos[m + 2] - yearpos[m + 1]) # Define sequence of "days" values
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) + 0.5) * 365 | days < ((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid[1:(yearpos[m + 1] - yearpos[m])]) # Add sinusoid values for first bit of record to the vector
}else if(m == (length(yearpos) - 1)){ # end of the record
maxpos <- which(dat[yearpos[m - 1] : (yearpos[m] - 1), 2] == max(dat[yearpos[m - 1] : (yearpos[m] - 1), 2])) + yearpos[m - 1] - 1 # Find the position of the maximum value in the d18O data of the previous year (the last year that is complete)
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(1, yearpos[m + 1] - yearpos[m - 1], 1) * 365 / (yearpos[m] - yearpos[m - 1]) # Define sequence of "days" values
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) + 0.5) * 365 | days < ((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid[(yearpos[m] - yearpos[m - 1]):(yearpos[m + 1] - yearpos[m - 1])]) # Add sinusoid values for last bit of record to the vector
}
}
maxpos <- which(dat[yearpos[m] : (yearpos[m + 1] - 1), 2] == max(dat[yearpos[m] : (yearpos[m + 1] - 1), 2])) + yearpos[m] - 1 # Find the position of the maximum value in the d18O data in that year
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
maxpos
m=3
maxpos <- which(dat[yearpos[m] : (yearpos[m + 1] - 1), 2] == max(dat[yearpos[m] : (yearpos[m + 1] - 1), 2])) + yearpos[m] - 1 # Find the position of the maximum value in the d18O data in that year
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
maxpos
days <- seq(1, yearpos[m + 1] - yearpos[m], 1) * 365 / (yearpos[m + 1] - yearpos[m]) # Define sequence of "days" values with length = number of datapoints in the year
days
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid
sinusoid[which(days > ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) + 0.5) * 365 | days < ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) - 0.5) * 365)] <- -1
sinusoid
YE18O <- append(YE18O, sinusoid) # add sinusoid values to running vector
YE18O
yearpos <- c(1, which(JDends[, 2] == 1), length(JDends$Depth)) # Extract positions of yearmarkers and include start and end of record
yearpos <- unique(yearpos) # Remove duplicates in yearpos due to yearmarkers on beginning and/or end of record
YE18O <- vector() # Create vector for the position of the maximum d18O value
for(m in 1:(length(yearpos) - 1)){ # Loop through positions of yearmarkers
if(m %in% 2:(length(yearpos) - 2)){ # central part of the record
maxpos <- which(dat[yearpos[m] : (yearpos[m + 1] - 1), 2] == max(dat[yearpos[m] : (yearpos[m + 1] - 1), 2])) + yearpos[m] - 1 # Find the position of the maximum value in the d18O data in that year
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(1, yearpos[m + 1] - yearpos[m], 1) * 365 / (yearpos[m + 1] - yearpos[m]) # Define sequence of "days" values with length = number of datapoints in the year
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) + 0.5) * 365 | days < ((maxpos - yearpos[m]) / (yearpos[m + 1] - yearpos[m]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid) # add sinusoid values to running vector
}else if(m == 1){ # beginning of the record
maxpos <- which(dat[yearpos[m + 1] : (yearpos[m + 2] - 1), 2] == max(dat[yearpos[m + 1] : (yearpos[m + 2] - 1), 2])) + yearpos[m + 1] - 1 # Find the position of the maximum value in the d18O data of the next year (the first year that is complete)
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(yearpos[m] - yearpos[m + 1] + 1, yearpos[m + 2] - yearpos[m + 1], 1) * 365 / (yearpos[m + 2] - yearpos[m + 1]) # Define sequence of "days" values
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) + 0.5) * 365 | days < ((maxpos - yearpos[m + 1]) / (yearpos[m + 2] - yearpos[m + 1]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid[1:(yearpos[m + 1] - yearpos[m])]) # Add sinusoid values for first bit of record to the vector
}else if(m == (length(yearpos) - 1)){ # end of the record
maxpos <- which(dat[yearpos[m - 1] : (yearpos[m] - 1), 2] == max(dat[yearpos[m - 1] : (yearpos[m] - 1), 2])) + yearpos[m - 1] - 1 # Find the position of the maximum value in the d18O data of the previous year (the last year that is complete)
if(length(maxpos) > 1){
maxpos = round(stats::median(maxpos)) # Prevent multiple values in maxpos (gives errors further in the calculations)
}
days <- seq(1, yearpos[m + 1] - yearpos[m - 1], 1) * 365 / (yearpos[m] - yearpos[m - 1]) # Define sequence of "days" values
sinusoid <- sin(2 * pi * (days - rep((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) * 365 - 365 / 4, length(days))) / 365) # Create sinusoid with peak at peak in d18Oc
sinusoid[which(days > ((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) + 0.5) * 365 | days < ((maxpos - yearpos[m - 1]) / (yearpos[m] - yearpos[m - 1]) - 0.5) * 365)] <- -1 # Assign lowest value (-1) to all datapoints more than 1/2 period away from the maximum to prevent false peaks
YE18O <- append(YE18O, sinusoid[(yearpos[m] - yearpos[m - 1]):(yearpos[m + 1] - yearpos[m - 1])]) # Add sinusoid values for last bit of record to the vector
}
}
JDends$YE18O <- scales::rescale(YE18O, c(0, 1)) # Add normalized results to depth series
View(JDends)
JDends$YEcombined <- scales::rescale(rowSums(JDends[, -c(1,2)]), c(0, 1)) # Combine all four methods of peak recognition into one vector
wmin <- round(min(diff(which(JDends[,2] == 1))) / 4) # Define starting window for peak recognition as one forth the minimum width of a year
wmax <- round(min(diff(which(JDends[,2] == 1))) / 2) # Define maximum window for peak recognition as half the minimum width of a year
YM <- length(which(JDends[,2] == 1)) # Extract number of years in record
X <- list(w = vector(), p = vector()) # List for storing results
w <- wmin # Start at minimum window size
repeat{
peaks <- peakid(JDends$Depth, JDends$YEcombined, w = w, span = 0.05) # Identify peaks based on current threshold
if(length(peaks$x) == YM){ # Check if the number of years is correct and break loop if it is
break
}else if(w < wmax){ # Check if maximum window is reached
X$w <- append(X$w, w) # Store window size
X$p <- append(X$p, length(peaks$x)) # Store peak number
w <- w + 1 # Increment window size
}else{
X$w <- append(X$w, w) # Store window size
X$p <- append(X$p, length(peaks$x)) # Store peak number
w <- max(X$w[which(abs(X$p - YM) == min(abs(X$p - YM)))]) # If no windows give the exact number of years, take the window that comes closer (prioritize larger windows in case of a tie)
peaks <- peakid(JDends$Depth, JDends$YEcombined, w = w, span = 0.05) # Recalculate peak positions with the final chosen window size before breaking the loop
break
}
}
peaks
JDends$peakid <- rep(0, length(JDends[,1])) # Add column for peakid results
JDends$peakid[peaks$i] <- 1 # Mark the location of peaks found in the time series
dev.new()
graphics::plot(JDends$Depth,
JDends$YEcombined,
type = "l",
main = "Peak fitting results",
xlab = "Depth",
ylab = "Probability of end of year") # Plot aggregate of yearmarkers
points(peaks$x, rep(1, length(peaks$x)), col = "red") # Plot location of yearmarkers
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
View(JDdat)
col = 1
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
window
peakx
peaks$x
dat[which(!is.na(window)), 1]
which(peaks$x %in% dat[which(!is.na(window)), 1])
which(dat[, 1] == peaks$x[peakx] & !is.na(window))
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col]
JDpeak
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
window
length(which(diff(window) < 0)) > 0
col = 2
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
window
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
peakx
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col]
JDpeak
peakx
col=3
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
window
length(which(diff(window) < 0)) > 0
which(diff(window) < 0)
peakx
which(dat[, 1] == peaks$x[peakx])
if(length(which(diff(window) < 0)) > 0){ # Check if year transitions occur within the simulation
for(i in which(diff(window) < 0)){
if(length(peakx) > 0){ # Check if global year transitions occur within the window
if(i < which(dat[, 1] == peaks$x[peakx])){
window[1:i] <- window[1:i] - 365 # If the transition happens before the reference point (peakx), subtract a year's worth of days from the values before to prevent adding a year twice.
}
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # Add one year's worth of days to simulations after each transition
}
}
}
window
rm(col)
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
for(col in 1:length(JDdat[1, ])){ # Loop through all simulation windows
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
if(length(which(diff(window) < 0)) > 0){ # Check if year transitions occur within the simulation
for(i in which(diff(window) < 0)){
if(length(peakx) > 0){ # Check if global year transitions occur within the window
if(i < which(dat[, 1] == peaks$x[peakx])){
window[1:i] <- window[1:i] - 365 # If the transition happens before the reference point (peakx), subtract a year's worth of days from the values before to prevent adding a year twice.
}
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # Add one year's worth of days to simulations after each transition
}
}
}
JDdat[, col] <- window # Update the julian day data with the new cumulative day simulations
}
View(JDdat)
col = 5
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
window
peakx
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
window
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
peakx
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col]
JDpeak
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
window
length(which(diff(window) < 0)) > 0
which(diff(window) < 0)
i <- which(diff(window) < 0)
i
i < which(dat[, 1] == peaks$x[peakx])
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365
window
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
for(col in 1:length(JDdat[1, ])){ # Loop through all simulation windows
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
if(length(which(diff(window) < 0)) > 0){ # Check if year transitions occur within the simulation
for(i in which(diff(window) < 0)){
if(length(peakx) > 0){ # Check if global year transitions occur within the window
if(i < which(dat[, 1] == peaks$x[peakx])){
window[1:i] <- window[1:i] - 365 # If the transition happens before the reference point (peakx), subtract a year's worth of days from the values before to prevent adding a year twice.
}
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # Add one year's worth of days to simulations after each transition
}
}
}
JDdat[, col] <- window # Update the julian day data with the new cumulative day simulations
}
JDdat
View(JDdat)
col = 5
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
if(length(which(diff(window) < 0)) > 0){ # Check if year transitions occur within the simulation
for(i in which(diff(window) < 0)){
if(length(peakx) > 0){ # Check if global year transitions occur within the window
if(i < which(dat[, 1] == peaks$x[peakx])){
window[1:i] <- window[1:i] - 365 # If the transition happens before the reference point (peakx), subtract a year's worth of days from the values before to prevent adding a year twice.
}
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # Add one year's worth of days to simulations after each transition
}
}
}
window
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
window
length(which(diff(window) < 0)) > 0
length(peakx) > 0
i < which(dat[, 1] == peaks$x[peakx])
i < which(dat[, 1] == peaks$x[peakx])
which(dat[, 1] == peaks$x[peakx])
peakx
which(dat[, 1] == peaks$x[peakx])
JDdat <- resultarray[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3] # Isolate julian day simulations
for(col in 1:length(JDdat[1, ])){ # Loop through all simulation windows
window <- JDdat[, col] # Isolate simulation window
peakx <- head(which(peaks$x %in% dat[which(!is.na(window)), 1]), 1) # Find position of the first year end in the window column
if(length(peakx) == 0){
if(peaks$x[1] < dat[head(which(!is.na(window)), 1), 1]){ # If no global year transitions fall within the window, check if there are global year transitions before the window and find the last year transition before the first value in the window
peakx <- max(which(peaks$x < dat[head(which(!is.na(window)), 1), 1]))
window <- window + peakx * 365 # And add the number of years associated with this last transition to all window values
} # If all year transitions happen after the window, no year number needs to be added to the window values
}else{
JDpeak <- JDdat[tail(which(dat[, 1] == peaks$x[peakx] & !is.na(window)), 1), col] # Find JD simulation belonging to the first year transition
if(JDpeak < 182.5){
window <- window + peakx * 365 # If year transition co-occurs with first half of the simulated year, all simulated values are assumed to belong to the next year
}else{
window <- window + (peakx - 1) * 365 # If year transition co-occurs with last half of the simulated year, all simulated values are assumed to belong to the previous year
}
}
if(length(which(diff(window) < 0)) > 0){ # Check if year transitions occur within the simulation
for(i in which(diff(window) < 0)){
if(length(peakx) > 0){ # Check if global year transitions occur within the window
if(i < which(dat[, 1] == peaks$x[peakx])){
window[1:i] <- window[1:i] - 365 # If the transition happens before the reference point (peakx), subtract a year's worth of days from the values before to prevent adding a year twice.
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # If the transition happens on or after the reference point (peakx), add one year's worth of days to simulations after each transition
}
}else{
window[(i + 1):length(window)] <- window[(i + 1):length(window)] + 365 # If no global transitions occur within the window, add one year's worth of days to simulations after each local transition
}
}
}
JDdat[, col] <- window # Update the julian day data with the new cumulative day simulations
}
View(JDdat)
result <- resultarray[, , 3]
result[, 6:length(result[1, ])] <- JDdat # Add the updated cumulative julian day results to the resultarray and export
View(result)
window
JDdat <- resultarray_original[, (length(dat[1, ]) + 1):length(resultarray[1, , 1]), 3]
View(JDdat)
